<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Copland</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Copland</h1>
        <p>Semantics, languages and tools for layered attestation</p>

	<ul>
    	
    	<li><a href="/blog/2021/08/31/Automated-Trust-Analysis-Paper-Published.html">Automated Trust Analysis Paper Accepted</a></li>
    	
    	<li><a href="/blog/2021/08/30/MEMOCODE-Paper-Accepted.html">MEMOCODE Paper Accepted</a></li>
    	
    	<li><a href="/blog/2021/05/28/nfm21-presentation.html">NFM '21 (Virtual) Conference Presentation</a></li>
    	
    	<li><a href="/blog/2021/05/20/Copland-Collection-Released.html">Copland Collection Released</a></li>
    	
    	<li><a href="/blog/2021/02/24/NFM-Paper-Accepted.html">NFM Paper Accepted</a></li>
    	
    	<li><a href="/blog/2021/01/12/Haskell-Attestation-Manager-Release.html">Haskell Attestation Manager Release</a></li>
    	
    	<li><a href="/blog/2021/01/12/CakeML-Attestation-Manager-Release.html">CakeML Attestation Manager Release</a></li>
    	
    	<li><a href="/blog/2020/12/31/Tutorial-Update.html">Tutorial Update</a></li>
    	
    	<li><a href="/blog/2020/12/22/Copland-Tutorial-Added.html">Copland Tutorial Added</a></li>
    	
    	<li><a href="/blog/2019/06/24/Haskell-AM-Initial-Release.html">Haskell AM Initial Release</a></li>
    	
    	</ul>

        <a href="">Home</a><br>
        <a href="publications.html">Publications</a><br>
        <a href="documentation.html">Documentation</a><br>
        <a href="software.html">Software</a><br>
        <a href="blog.html">Blog</a><br>

      </header>
      <section>
      <h1 id="use-cases-for-remote-attestation">Use Cases for Remote Attestation</h1>

<p align="center">Ian D. Kretz, John D. Ramsdell, and Paul D. Rowe<br />
The MITRE Corporation</p>

<p>This note presents a series of use cases for remote attestation.  Each
includes a number of Copland phrases that specify how relevant target
components are measured and by whom, the order in which these
measurements occur, and how the evidence produced by these
measurements is bundled together.</p>

<p>Associated with each example Copland phrase is an XHTML document that
visualizes the phrases’s abstract syntax tree and shows how evidence
is accumulated as the phrase executes, culminating in the final
evidence that characterizes the phrase.  These documents can be
generated by running <code class="language-plaintext highlighter-rouge">make</code> in the directory that contains this
<code class="language-plaintext highlighter-rouge">README</code>.</p>

<p>The categories of use case are:</p>

<ul>
  <li><a href="mutual/mutual">Mutual attestation</a></li>
  <li><a href="cert/cert">Certificate-style attestation</a></li>
  <li><a href="delegated/delegated">Delegated appraisal</a></li>
</ul>

<p>We repeatedly rely on an incremental approach to writing Copland
phrases, starting from simpler ones whose correctness is easily
verified and gradually building up complexity.  We generally advocate
for such an approach to writing phrases.</p>

<hr />

<p>What follows is an introduction to Copland phrase syntax and
semantics.  The section on semantics helps interpret the XHTML
document generated from a Copland phrase. We assume the reader is
familiar with <a href="https://ku-sldg.github.io/copland/resources/copland-post-2019.pdf">Orchestrating Layered Attestation</a>.  What is
presented here is a slight variation of what is described in the
paper.</p>

<h2 id="copland-syntax">Copland Syntax</h2>

<p>A symbol is a lowercase letter optionally followed by letters, digits,
and underscores.  The syntax of a Copland phrase is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COPLAND ::= * PLACE : PHRASE | PHRASE

PLACE   ::= SYMBOL | DIGITS

PHRASE  ::= SYMBOL PLACE SYMBOL      -- Measurement (probe place target)
         |  {}                       -- Null
         |  _                        -- Copy
         |  !                        -- Signature
         |  #                        -- Hash
         |  @ PLACE PHRASE           -- At place
         |  @ PLACE [ PHRASE ]       -- At place with brackets
         |  PHRASE -&gt; PHRASE         -- Linear sequencing
         |  PHRASE BRANCH PHRASE     -- Sequential and parallel branching
         |  ( PHRASE )

BRANCH  ::= -&lt;- | +&lt;- | -&lt;+ | +&lt;+    -- Sequential
         |  -~- | +~- | -~+ | +~+    -- Parallel
</code></pre></div></div>

<p>The initial place <code class="language-plaintext highlighter-rouge">P</code> is specified using <code class="language-plaintext highlighter-rouge">*P:</code>, and this place
defaults to <code class="language-plaintext highlighter-rouge">p0</code> when left unspecified.</p>

<p>The @ operator has the lowest precedence, the branching operator is
non-associative and has medium precedence, and linear sequencing
operator is right associative and has the highest precedence.  Thus</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*p0: @p1 kim p2 ker -&gt; ! -&lt;- @p2 (vc p2 sys) -&gt; !
</code></pre></div></div>

<p>Is equivalent to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*p0: @p1 (((kim p2 ker) -&gt; !) -&lt;- (@p2 ((vc p2 sys) -&gt; !)))
</code></pre></div></div>

<p>Notice that the largest Copland phrase that follows an @ operator is
the one that is associated with it when brackets are omitted.</p>

<p>When a place is a sequence of digits, it is equivalent to the symbol
that results from adding the letter <code class="language-plaintext highlighter-rouge">p</code> to the beginning of the digits.</p>

<p>The comment character is percent.</p>

<h2 id="copland-semantics">Copland Semantics</h2>

<p>Associated with each Copland phrase is a term that describes the type
of evidence collected by the phrase.  Additionally, each Copland
phrase has a precise semantics based on partially ordered sets of
events, in which events are labeled.</p>

<h3 id="evidence-types">Evidence Types</h3>

<p>The syntax of evidence type <code class="language-plaintext highlighter-rouge">EVIDENCE</code> is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EVIDENCE ::= mt
          |  m(msp(SYMBOL, PLACE, SYMBOL), PLACE, EVIDENCE)
          |  g(EVIDENCE, PLACE) | H(EVIDENCE, PLACE)
          |  s(EVIDENCE, EVIDENCE)
          |  p(EVIDENCE, EVIDENCE)
</code></pre></div></div>

<p>The empty evidence type is <code class="language-plaintext highlighter-rouge">mt</code>.  The set of possible reports
generated by measurement request <code class="language-plaintext highlighter-rouge">S Q T</code> at <code class="language-plaintext highlighter-rouge">P</code> given previous
evidence <code class="language-plaintext highlighter-rouge">V</code> is <code class="language-plaintext highlighter-rouge">m(msp(S, Q, T), P, V)</code>, where <code class="language-plaintext highlighter-rouge">msp(S, Q, T)</code> is an
event label to be explained later.  The evidence gained by signing <code class="language-plaintext highlighter-rouge">V</code>
at <code class="language-plaintext highlighter-rouge">P</code> is <code class="language-plaintext highlighter-rouge">g(V, P)</code>, and evidence gained by hashing <code class="language-plaintext highlighter-rouge">V</code> at <code class="language-plaintext highlighter-rouge">P</code> is
<code class="language-plaintext highlighter-rouge">H(V, P)</code>.  Evidence of the form <code class="language-plaintext highlighter-rouge">s(V1, V2)</code> asserts that the report
in <code class="language-plaintext highlighter-rouge">V1</code> was produced before the report in <code class="language-plaintext highlighter-rouge">V2</code>, and evidence of the
form <code class="language-plaintext highlighter-rouge">p(V1, V2)</code> makes no assertion about the ordering of the report
in <code class="language-plaintext highlighter-rouge">V1</code> relative to the one in <code class="language-plaintext highlighter-rouge">V2</code>.</p>

<h3 id="event-semantics">Event Semantics</h3>

<p>Semantically, a Copland phrase specifies the mapping of input
evidence to some output evidence via one or more attestation events.
Each event occurs at a well defined place.  Events involve taking
measurements, signing or hashing evidence, or routing evidence so as
to produce combinations of evidence.</p>

<p>To describe the semantics of executing Copland phrase <code class="language-plaintext highlighter-rouge">C</code> at place
<code class="language-plaintext highlighter-rouge">P</code>, we describe how it transforms evidence of type <code class="language-plaintext highlighter-rouge">V</code> into evidence of
type <code class="language-plaintext highlighter-rouge">f(V)</code>, making use of diagrams of the form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  V   +-------+   f(V)
----&gt; | LABEL | -------&gt;
      +-------+
</code></pre></div></div>

<p>The box represents an event, and the arrows show the flow of evidence.
The ordering of events respects the flow of evidence.  The syntax of
an event label is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LABEL ::= PLACE:msp(SYMBOL, PLACE, SYMBOL)
       |  PLACE:nul | PLACE:cpy | PLACE:sig | PLACE:hsh
       |  PLACE:req(PLACE) | PLACE:rpy(PLACE)
       |  PLACE:BRANCH split | PLACE:join
</code></pre></div></div>

<p>The initial evidence associated with a phrase is the empty evidence
<code class="language-plaintext highlighter-rouge">mt</code>.</p>

<p>The most basic Copland phrase is a measurement <code class="language-plaintext highlighter-rouge">S Q T</code>, for symbols
<code class="language-plaintext highlighter-rouge">S</code> and <code class="language-plaintext highlighter-rouge">T</code>, and place <code class="language-plaintext highlighter-rouge">Q</code>, where <code class="language-plaintext highlighter-rouge">S</code> names the measurement, <code class="language-plaintext highlighter-rouge">T</code> names
the target of the measurement, and <code class="language-plaintext highlighter-rouge">Q</code> is the place at which the
target resides.  When at place <code class="language-plaintext highlighter-rouge">P</code> with input evidence <code class="language-plaintext highlighter-rouge">V</code>, <code class="language-plaintext highlighter-rouge">S Q T</code>
means that <code class="language-plaintext highlighter-rouge">P</code> should receive <code class="language-plaintext highlighter-rouge">V</code>, perform <code class="language-plaintext highlighter-rouge">S</code> targeting <code class="language-plaintext highlighter-rouge">T</code> at <code class="language-plaintext highlighter-rouge">Q</code>,
and then emit the resulting evidence <code class="language-plaintext highlighter-rouge">f(V)</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  V   +--------------+   f(V)
----&gt; | P:msp(S,Q,T) | -------&gt;
      +--------------+
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">f(V)= m(msp(S, Q, T), P, V)</code>.  Evidence type <code class="language-plaintext highlighter-rouge">m(E, P, V)</code>
denotes the type of evidence produced by Measurement SPecification <code class="language-plaintext highlighter-rouge">E</code>
at P starting with evidence of type <code class="language-plaintext highlighter-rouge">V</code>.</p>

<p>Let <code class="language-plaintext highlighter-rouge">P:{C}</code> be the events and their orderings associated with
executing phrase <code class="language-plaintext highlighter-rouge">C</code> at <code class="language-plaintext highlighter-rouge">P</code>.  Measurements can be combined in a
pipeline fashion using the <code class="language-plaintext highlighter-rouge">-&gt;</code> operator.  Thus when at <code class="language-plaintext highlighter-rouge">P</code> with input
evidence <code class="language-plaintext highlighter-rouge">V</code>, <code class="language-plaintext highlighter-rouge">C1 -&gt; C2</code> means</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  V            f1(V)            f2(f1(V))
----&gt; P:{C1} --------&gt; P:{C2} ------------&gt;
</code></pre></div></div>

<p>Measurements can be taken at a remote locations using the <code class="language-plaintext highlighter-rouge">@</code> operator.
When at <code class="language-plaintext highlighter-rouge">P</code> with input evidence <code class="language-plaintext highlighter-rouge">V</code>, <code class="language-plaintext highlighter-rouge">@Q[C]</code> means</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  V   +----------+   V           f(V)   +----------+   f(V)
----&gt; | P:req(Q) | ----&gt; Q:{C} -------&gt; | P:rpy(Q) | -------&gt;
      +----------+                      +----------+
</code></pre></div></div>

<p>Phrases <code class="language-plaintext highlighter-rouge">C1</code> and <code class="language-plaintext highlighter-rouge">C2</code> can be combined using branching.  There are
several ways of combining phrases using branching, but they all follow
the same split-join pattern.  When at <code class="language-plaintext highlighter-rouge">P</code> with input evidence <code class="language-plaintext highlighter-rouge">V</code>, <code class="language-plaintext highlighter-rouge">C1
BRANCH C2</code> means</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                           V1           f1(V1)
                         -----&gt; P:{C1} ---------&gt;
  V   +----------------+/                        \+--------+   V0
----&gt; | P:BRANCH split |                          | P:join | -----&gt;
      +----------------+\  V2           f2(V2)   /+--------+
                         -----&gt; P:{C2} ---------&gt;
</code></pre></div></div>

<p>There are two dimensions by which branching differs.  The split event
may pass its input evidence to a phrase or hide it from that phrase by
sending the empty evidence.  Additionally, the execution of phrase
<code class="language-plaintext highlighter-rouge">C1</code> may be required to finish before phrase <code class="language-plaintext highlighter-rouge">C2</code> starts, or both are
allowed to execute in parallel.</p>

<p>Three characters make up a branching operator. If the middle character
is <code class="language-plaintext highlighter-rouge">&lt;</code>, sequential branching is specified, and <code class="language-plaintext highlighter-rouge">V0 = s(f1(V1),
f2(V2))</code>.  Otherwise the middle character is <code class="language-plaintext highlighter-rouge">~</code>, parallel branching
is specified, and <code class="language-plaintext highlighter-rouge">V0 = p(f1(V1), f2(V2))</code>.  When sequential branching
is specified, every event in <code class="language-plaintext highlighter-rouge">P:{C1}</code> occurs before every event in
<code class="language-plaintext highlighter-rouge">P:{C2}</code>.  Otherwise, these sets of events are not ordered.</p>

<p>The actions of the split event are specified by the <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">-</code>
characters.  If the first character in the operator is <code class="language-plaintext highlighter-rouge">+</code>, then <code class="language-plaintext highlighter-rouge">V1 =
V</code>.  Otherwise, the first character is <code class="language-plaintext highlighter-rouge">-</code>, and <code class="language-plaintext highlighter-rouge">V1 = mt</code>.  The third
character in the operator specifies the value of <code class="language-plaintext highlighter-rouge">V2</code> similarly.</p>

<p>There are four phrases that specify single events.</p>

<p>Hashing is specified using <code class="language-plaintext highlighter-rouge">#</code>.  When at <code class="language-plaintext highlighter-rouge">P</code> with input evidence <code class="language-plaintext highlighter-rouge">V</code>,
<code class="language-plaintext highlighter-rouge">#</code> means</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  V   +-------+   h(V, P)
----&gt; | P:hsh | ----------&gt;
      +-------+
</code></pre></div></div>

<p>Signing is specified using <code class="language-plaintext highlighter-rouge">!</code>.  When at <code class="language-plaintext highlighter-rouge">P</code> with input evidence <code class="language-plaintext highlighter-rouge">V</code>,
<code class="language-plaintext highlighter-rouge">!</code> means</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  V   +-------+   g(V, P)
----&gt; | P:sig | ----------&gt;
      +-------+
</code></pre></div></div>

<p>Copying is specified using <code class="language-plaintext highlighter-rouge">_</code>.  When at <code class="language-plaintext highlighter-rouge">P</code> with input evidence
<code class="language-plaintext highlighter-rouge">V</code>,<code class="language-plaintext highlighter-rouge">_</code> means</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  V   +-------+   V
----&gt; | P:cpy | -----&gt;
      +-------+
</code></pre></div></div>

<p>Nullifying is specified using <code class="language-plaintext highlighter-rouge">{}</code>.  When at <code class="language-plaintext highlighter-rouge">P</code> with input evidence
<code class="language-plaintext highlighter-rouge">V</code>, <code class="language-plaintext highlighter-rouge">{}</code> means</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  V   +-------+   mt
----&gt; | P:nul | -----&gt;
      +-------+
</code></pre></div></div>

<h2 id="xhtml-rendering">XHTML Rendering</h2>

<p>A tool creates an XHTML document from a Copland phrase that contains
the phrase and a visualization of its semantics.  The document
contains the phrase that was analyzed, a diagram of the abstract
syntax of the phrase that makes it clear how it is parsed, and a
diagram showing its event semantics.</p>

<p>The diagram contains two types of nodes.  An oval represents an event
and it contain the event’s label.  A box represents evidence.</p>

<p>A black arrow shows both a flow of data and an ordering of events.  A
red arrow indicates an additional ordering of events due to the use of
a sequential branching operator.  A blue arrow connects a request with
its matching reply.</p>

<p>Events and evidence passing that occur at one place are collected
together within a surrounding rectangle.  The place associated with
the rectangle is displayed in the upper right corner of the rectangle.</p>

<hr />

<p>© 2020 The MITRE Corporation.</p>

<p>Approved for Public Release; Distribution Unlimited. Public Release
Case Number 20-2549</p>

<p>The view, opinions, and/or findings contained in this report are those
of The MITRE Corporation and should not be construed as an official
Government position, policy, or decision, unless designated by other
documentation.</p>

<p>This technical data deliverable was developed using contract funds
under Basic Contract No. W56KGU-18-D-0004.</p>


      </section>
      <footer>
        <p>Visit Copland on <a href="https://github.com/ku-sldg/copland">GitHub</a></p>
<p>Maintained by <a href="https://github.com/palexand">Perry Alexander</a></p>
<p><small>Hosted on GitHub Pages </br> Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>

      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
