<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Copland</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Copland</h1>
        <p>Semantics, languages and tools for layered attestation</p>

	<ul>
    	
    	<li><a href="/blog/2021/08/31/Automated-Trust-Analysis-Paper-Published.html">Automated Trust Analysis Paper Accepted</a></li>
    	
    	<li><a href="/blog/2021/08/30/MEMOCODE-Paper-Accepted.html">MEMOCODE Paper Accepted</a></li>
    	
    	<li><a href="/blog/2021/05/28/nfm21-presentation.html">NFM '21 (Virtual) Conference Presentation</a></li>
    	
    	<li><a href="/blog/2021/05/20/Copland-Collection-Released.html">Copland Collection Released</a></li>
    	
    	<li><a href="/blog/2021/02/24/NFM-Paper-Accepted.html">NFM Paper Accepted</a></li>
    	
    	<li><a href="/blog/2021/01/12/Haskell-Attestation-Manager-Release.html">Haskell Attestation Manager Release</a></li>
    	
    	<li><a href="/blog/2021/01/12/CakeML-Attestation-Manager-Release.html">CakeML Attestation Manager Release</a></li>
    	
    	<li><a href="/blog/2020/12/31/Tutorial-Update.html">Tutorial Update</a></li>
    	
    	<li><a href="/blog/2020/12/22/Copland-Tutorial-Added.html">Copland Tutorial Added</a></li>
    	
    	<li><a href="/blog/2019/06/24/Haskell-AM-Initial-Release.html">Haskell AM Initial Release</a></li>
    	
    	</ul>

        <a href="">Home</a><br>
        <a href="publications.html">Publications</a><br>
        <a href="documentation.html">Documentation</a><br>
        <a href="software.html">Software</a><br>
        <a href="blog.html">Blog</a><br>

      </header>
      <section>
      <h1 id="theory-of-minimal-adversary-ordered-saturated-queries">Theory of minimal, adversary-ordered, saturated queries</h1>

<p>Chaseâ€™s scheduling is sensitive to the order in which phrases are
listed. Changing the order may drastically affect performance.</p>

<h2 id="minimality-conditions">Minimality Conditions</h2>

<p>Record measurement events:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l(E) = msp(P2, E1, M, P1, T) =&gt; ms_evt(E).
</code></pre></div></div>
<p>Any two alternating adversary events for the same component must have a
measurement event in between. (This disallows models with pointless chains of
cor-rep events.)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l(E1) = cor(P, C) &amp; l(E2) = rep(P, C) &amp; prec(E1, E2)
 =&gt; prec(E1, E3) &amp; prec(E3, E2) &amp; ms_evt(E3) &amp; relevant(P, C, E3).
l(E1) = rep(P, C) &amp; l(E2) = cor(P, C) &amp; prec(E1, E2)
 =&gt; prec(E1, E3) &amp; prec(E3, E2) &amp; ms_evt(E3) &amp; relevant(P, C, E3).
</code></pre></div></div>

<p>Two adversary events of the same type for the same component must have an
intervening adversary event of the opposite type for that component.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l(E1) = cor(P,C) &amp; l(E2) = cor(P,C) &amp; prec(E1, E2)
 =&gt; prec(E1, E3) &amp; prec(E3, E2) &amp; l(E3) = rep(P,C).
l(E1) = rep(P,C) &amp; l(E2) = rep(P,C) &amp; prec(E1, E2)
 =&gt; prec(E1, E3) &amp; prec(E3, E2) &amp; l(E3) = cor(P,C).

l(E) = msp(P2, E1, M, P1, T) &amp; relevant(P, C, E)
 =&gt; P = P1 &amp; C = T | P = P2 &amp; C = M | P = P2 &amp; depends(P2, C, P2, M).
</code></pre></div></div>

<h2 id="events-are-injective">Events are injective</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cor(P1, C1) = cor(P2, C2) =&gt; P1 = P2 &amp; C1 = C2.
rep(P1, C1) = rep(P2, C2) =&gt; P1 = P2 &amp; C1 = C2.
cor(P1, C1) = rep(P2, C2) =&gt; false.
cor(P1, C1) = msp(P2, E, M, Q, T) =&gt; false.
rep(P1, C1) = msp(P2, E, M, Q, T) =&gt; false.
msp(P1, E1, M1, Q1, T1) = msp(P2, E2, M2, Q2, T2)
  =&gt; P1 = P2 &amp; E1 = E2 &amp; M1 = M2 &amp; Q1 = Q2 &amp; T1 = T2.
</code></pre></div></div>

<h2 id="strict-partial-orders">Strict partial orders</h2>

<p>Irreflexivity:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prec(E, E) =&gt; false.
depends(P, C, P, C) =&gt; false.
</code></pre></div></div>
<p>Transitivity:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prec(E1, E2) &amp; prec(E2, E3) =&gt; prec(E1, E3).
depends(P1, C1, P2, C2) &amp; depends(P2, C2, P3, C3)
  =&gt; depends(P1, C1, P3, C3).
</code></pre></div></div>

<h2 id="adversary-ordered-event-systems">Adversary Ordered Event Systems</h2>

<p>Introduction of relevant:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l(E) = msp(P2, E1, M, P1, T) &amp; depends(P2, C, P2, M)
	=&gt; relevant(P2, M, E) &amp; relevant(P1, T, E)
	   &amp; relevant(P2, C, E).
l(E) = msp(P2, E1, M, P1, T)
	=&gt; relevant(P2, M, E) &amp; relevant(P1, T, E).
l(E) = cor(P, C) =&gt; relevant(P, C, E).
l(E) = rep(P, C) =&gt; relevant(P, C, E).
</code></pre></div></div>
<p>Adversary ordered:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>relevant(P, C, E1) &amp; relevant(P, C, E2) &amp; l(E1) = cor(P, C)
  =&gt; prec(E1, E2) | prec(E2, E1) | E1 = E2.
relevant(P, C, E1) &amp; relevant(P, C, E2) &amp; l(E1) = rep(P, C)
  =&gt; prec(E1, E2) | prec(E2, E1) | E1 = E2.
</code></pre></div></div>

<h2 id="saturated-queries">Saturated Queries</h2>

<p>Rule 1:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l(E) = msp(P2, E1, M, P1, T) &amp; phi(P1, T, E)
  =&gt; phi(P2, M, E) | depends(P2, C, P2, M) &amp; phi(P2, C, E).
</code></pre></div></div>
<p>Rule 2:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phi(P, C, E1)
 =&gt; prec(E0, E1) &amp; l(E0) = cor(P, C).
</code></pre></div></div>
<p>Rule 3:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prec(E1, E2) &amp; phi(P, C, E2) &amp; l(E1) = rep(P, C)
  =&gt; prec(E1, E3) &amp; prec(E3, E2) &amp; l(E3) = cor(P, C).
</code></pre></div></div>
<p>Rule 4:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l(E1) = cor(P2, C) &amp; ms_evt(E2) &amp; prec(E1, E2) &amp; relevant(P2, C, E2)
  =&gt; phi(P2, C, E2)
   | prec(E1, E3) &amp; prec(E3, E2) &amp; l(E3) = rep(P2, C).
</code></pre></div></div>

      </section>
      <footer>
        <p>Visit Copland on <a href="https://github.com/ku-sldg/copland">GitHub</a></p>
<p>Maintained by <a href="https://github.com/palexand">Perry Alexander</a></p>
<p><small>Hosted on GitHub Pages </br> Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>

      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
